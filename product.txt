// components/ProductForm.jsx
import { useState } from "react";

const ProductForm = ({ addProduct }) => {
  const [productName, setProductName] = useState("");
  const [price, setPrice] = useState("");
  const [category, setCategory] = useState("");
  const [inStock, setInStock] = useState(false);
  const [error, setError] = useState("");

  const handleSubmit = (e) => {
    e.preventDefault();

    if (!productName || price <= 0 || !category) {
      setError("Please fill all fields correctly.");
      return;
    }

    const newProduct = { productName, price, category, inStock };
    addProduct(newProduct);
    setProductName("");
    setPrice("");
    setCategory("");
    setInStock(false);
    setError("");
  };

  return (
    <form className="space-y-4" onSubmit={handleSubmit}>
      {error && <div className="text-red-500">{error}</div>}
      <input
        className="input"
        type="text"
        value={productName}
        onChange={(e) => setProductName(e.target.value)}
        placeholder="Product Name"
      />
      <input
        className="input"
        type="number"
        value={price}
        onChange={(e) => setPrice(e.target.value)}
        placeholder="Price"
      />
      <select
        className="input"
        value={category}
        onChange={(e) => setCategory(e.target.value)}
      >
        <option value="">Select Category</option>
        <option value="Electronics">Electronics</option>
        <option value="Clothing">Clothing</option>
        <option value="Books">Books</option>
      </select>
      <label className="flex items-center">
        <input
          type="checkbox"
          checked={inStock}
          onChange={() => setInStock(!inStock)}
        />
        In Stock
      </label>
      <button type="submit" className="btn">Add Product</button>
    </form>
  );
};

export default ProductForm;


// components/ProductList.jsx
import ProductItem from "./ProductItem";

const ProductList = ({ products, deleteProduct, editProduct }) => {
  return (
    <div>
      {products.length === 0 ? (
        <p>No products found.</p>
      ) : (
        <ul>
          {products.map((product, index) => (
            <ProductItem
              key={index}
              product={product}
              deleteProduct={() => deleteProduct(index)}
              editProduct={() => editProduct(index)}
            />
          ))}
        </ul>
      )}
    </div>
  );
};

export default ProductList;




// components/ProductItem.jsx
const ProductItem = ({ product, deleteProduct, editProduct }) => {
  return (
    <li className="flex justify-between items-center">
      <div>
        <p>{product.productName}</p>
        <p>{product.price} USD</p>
        <p>{product.category}</p>
        <p>{product.inStock ? "In Stock" : "Out of Stock"}</p>
      </div>
      <div className="space-x-2">
        <button onClick={editProduct} className="btn">Edit</button>
        <button onClick={deleteProduct} className="btn text-red-500">Delete</button>
      </div>
    </li>
  );
};

export default ProductItem;





// App.jsx
import { useState } from "react";
import ProductForm from "./components/ProductForm";
import ProductList from "./components/ProductList";
import { useLocalStorage } from "./hooks/useLocalStorage";

const App = () => {
  const [products, setProducts] = useLocalStorage("products", []);
  
  const addProduct = (newProduct) => {
    setProducts((prevProducts) => [...prevProducts, newProduct]);
  };

  const deleteProduct = (index) => {
    setProducts((prevProducts) => prevProducts.filter((_, i) => i !== index));
  };

  const editProduct = (index) => {
    // Open edit form (You can add a modal or directly populate the form)
  };

  return (
    <div className="container">
      <ProductForm addProduct={addProduct} />
      <ProductList
        products={products}
        deleteProduct={deleteProduct}
        editProduct={editProduct}
      />
    </div>
  );
};

export default App;



// hooks/useLocalStorage.js
import { useState } from "react";

export const useLocalStorage = (key, initialValue) => {
  const storedValue = localStorage.getItem(key);
  const parsedValue = storedValue ? JSON.parse(storedValue) : initialValue;

  const [value, setValue] = useState(parsedValue);

  const setStoredValue = (newValue) => {
    setValue(newValue);
    localStorage.setItem(key, JSON.stringify(newValue));
  };

  return [value, setStoredValue];
};




import React from "react";
import { useState } from "react";
import ProductForm from "./components/ProductForm.jsx";
import ProductList from "./components/ProductList.jsx";
import useLocalStorage from "./hooks/useLocalStorage.js";

function App() {
  const [products, setProducts] = useLocalStorage('products',[]);

  const onAddProduct = (product) =>
    setProducts((prev) => [...(Array.isArray(prev) ? prev : []), product]);

  const deleteProduct = (index) =>
    setProducts((prev) => (Array.isArray(prev) ? prev.filter((_, i) => i !== index) : prev));

  const handleEditProduct = (indexOrUpdate) => {
    // If caller provides an index, noop here â€” real edit flow not implemented.
    // If an update object is provided (has productName), apply it by index if possible.
    setProducts((prev) => {
      if (!Array.isArray(prev)) return prev;
      if (typeof indexOrUpdate === 'number') return prev;
      const updated = indexOrUpdate;
      return prev.map((product, i) => (i === updated.index ? updated : product));
    });
  };

  return (
    <div>
      <h1>Product Management Dashboard</h1>
      <ProductForm onAddProduct={onAddProduct} />
      <ProductList products={products} onDeleteProduct={deleteProduct} editProduct={handleEditProduct} />
    </div>
  );
}

export default App;




The code you provided is for managing a list of products using React state (presumably with `useState`). The code demonstrates how to add, delete, and edit items (products) in the state. Here's a breakdown of what each function does:

### 1. **`onAddProduct` function**

```javascript
const onAddProduct = (product) =>
    setProducts((prev) => [...(Array.isArray(prev) ? prev : []), product]);
```

* **Purpose**: Adds a new product to the list of products.
* **Explanation**:

  * `setProducts` is the function used to update the state of `products`.
  * `(prev) => [...]` is a function that updates the previous state.
  * `Array.isArray(prev) ? prev : []` ensures that if the `prev` state is not an array (i.e., if it's `null` or `undefined`), it will default to an empty array `[]`.
  * `product` is the new product that will be added to the `prev` array using the spread operator (`...`), which essentially adds `product` at the end of the array.

### 2. **`deleteProduct` function**

```javascript
const deleteProduct = (index) =>
    setProducts((prev) => (Array.isArray(prev) ? prev.filter((_, i) => i !== index) : prev));
```

* **Purpose**: Deletes a product from the list by its index.
* **Explanation**:

  * `setProducts` is again used to update the state.
  * `Array.isArray(prev) ? prev.filter((_, i) => i !== index) : prev` checks if the `prev` state is an array.
  * `.filter((_, i) => i !== index)` creates a new array that excludes the product at the specified `index`. The `_` means we're not using the actual product value, just the index (`i`).
  * If `prev` is not an array, it will simply return the unchanged `prev` state.

### 3. **`handleEditProduct` function**

```javascript
const handleEditProduct = (indexOrUpdate) => {
    setProducts((prev) => {
        if (!Array.isArray(prev)) return prev;
        if (typeof indexOrUpdate === 'number') return prev;
        const updated = indexOrUpdate;
        return prev.map((product, i) => (i === updated.index ? updated : product));
    });
};
```

* **Purpose**: Edits a product in the list based on its index or update object.
* **Explanation**:

  * `setProducts` is used to update the state.
  * `Array.isArray(prev)` checks if `prev` is an array. If it's not, it simply returns `prev` unchanged.
  * `typeof indexOrUpdate === 'number'` checks if the argument passed is an index. If it is a number (an index), the function will return the `prev` array without doing anything (i.e., no editing happens).
  * If the argument is not a number, it assumes `indexOrUpdate` is an object representing the updated product. The function then updates the product at the specified `index` using `prev.map`. It compares the index of each product (`i`) with `updated.index`. If they match, it replaces the product with `updated`, otherwise, it leaves the product unchanged.

### **Google Link Explanation**

The concepts you're working with here are common in React, especially when dealing with array manipulation in state management. Here are some helpful links that explain the core concepts you're using:

1. **React `useState` Hook** (for managing state in functional components):
   [React useState documentation](https://reactjs.org/docs/hooks-state.html)

2. **Array `map()` Method** (used for transforming arrays):
   [MDN map() method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)

3. **Array `filter()` Method** (used to create new arrays with filtered data):
   [MDN filter() method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)

4. **Spread Syntax (`...`)**:
   [MDN spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)

---

By using these methods in combination, you're managing an array of products effectively, allowing for additions, deletions, and updates within the state while adhering to React's functional component paradigm.

Let me know if you need more clarification on any part!
